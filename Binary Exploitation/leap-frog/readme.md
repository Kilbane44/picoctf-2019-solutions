# leap-frog - 300 Points

This is not the intended solution for this challenge. The intended solution is probably to:
* call leapA
* call leap3, but skip the "win1 == !win1" check
* call leap2
* call win() with the correct arguments
However I could not successfully call leap3 to bypass the "win1 == !win1" check without segfaulting.

Instead, this solution makes a call to libc's "gets" function which is able to write anything typed into stdin to any writable segment of memory.
This sovler writes 0x01 (aka "true") on top of the win1, win2, and win3 variables in memory to skip the need to call the leap functions.
Then win() is called.

Note: Libraries like libc are loaded with ASLR. This means the addresses of the libraries in memory are random every time. To deal with this, the solver
runs the program in a loop until gets happens to be at 0xf7e43ae1. It usually only takes a few seconds for libc to be loaded at the correct address.
Because of this, this may not work on your system depending on what the memory manager assigns as valid ASLR addresses. It should definitely work on the shell server, though.