# SecondLife - 400 Points

This problem is nearly identical to an example shown in a security presentation titled "Heap Overflows and Double-Free Attacks" by Yan Huang.

The problem involves exploiting the unlink function used by an older version of malloc called Doug Lea's Malloc (dlmalloc).

### Warning: the following explanation might only be semi-correct.

For a better explanation, see [these slides by Yan Huang](http://homes.sice.indiana.edu/yh33/Teaching/I433-2016/lec13-HeapAttacks.pdf).

----

A struct for a free chunk looks like this (pseudo-code):

```
struct freeChunk {
        int prev_size;
        int size;
        struct chunk *fd;
        struct chunk *bk;
};
```
where `fd` is a pointer to the next chunk of memory and `bk` is a pointer to the last chunk of memory.

The exploitable unlink function looks like this (pseudo-code):

```
#define unlink(P, BK, FD) {
 FD = P->fd;
 BK = P->bk;
 FD->bk = BK;
 BK->fd = FD;
} 
```

When malloc allocates a chunk, it has to rewrite the size, forward, and back pointers at the adjacent chunks so the memory allocater knows that the newly allocated chunk is in use.
If we can control the addresses of `P->fd` and `P->bk`, we can make malloc *think* it is updating the values of the chunks, but instead it is writing what we tell it to where we tell it to.

The program tells us the location of `first` in memory, then tells us to write shellcode to it. This shellcode is simply

```
push 0x08048956;
ret;
```

which will jump to the win function when executed. Note that we must add 12 bytes of padding before the shellcode since malloc will destroy them. This shellcode will be used later.

The second prompt lets us write on top of the `sixth` object. Note that before this prompt, **first was freed twice**. This means that this single block of memory can be allocated twice. When the malloc for `seventh` is called, it will try to unlink the "free" chunk from the other free chunks. When it does this, it will read the same block of memory as was allocated to sixth (which it believes to be a free block, not an allocated block). It will read the pointers written by the user and then use the above unlink function to rewrite the chunks at the user-specified free chunks. These pointers we write don't actually have to point to other free chunks: as long as we make our offsets right, we can make malloc set the value at the address we specify as `FD->bk` to `P->bk` and the address we specify as `BK->fw` to `P->fw`.

Based on the struct for the free chunk, `P->bk` will be P+12, and `P->fw` will be P+8. To solve this challenge, enter the address of exit in the GOT as the address for `P->fw`, subtracting 12 from the address since it will try to overwrite "bk", and enter the address of our shellcode (which is printed the program).

malloc will set the first 12 bytes at the heap address to `[GOT address (4)][Heap Address [4]][GOT address(4)]`. This means the bytes it writes need to pass as valid machine instructions for the exploit to work. Thankfully, the GOT address is valid, and since the heap address is random, if it doesn't pass initially, we can keep rerunning the program until it does. Eventually it will hit our shellcode to return to the win function and print the flag.