# Cereal Hacker 2 - 500 Points

This challenge involves combining several exploits to get the flag.

## Source code leak

The website loads PHP files using the file parameter in the URL:

![](https://puu.sh/ErVl0/f526137c03.png)

We can use the php://filter to make PHP encode a given file as Base64 and return it to the client. Note that the server automatically appends .php to the end of the file name, so exclude it here. Using this, we can investigate the source code for further bugs.

To leak a given file, set the following as the value for the file parameter:

```
php://filter/convert.base64-encode/resource=<file without .php goes here>
```

## Legacy authentication vulnerability

The obvious place to start would be leaking the source code for the login page. There's nothing super obvious here, *but* we can see other files being required at the top:

```
require_once('../sql_connect.php');
require_once('cookie.php');
```

sql_connect.php has the username and password for the SQL database, but the SQL server is not binded to the public IP address, so you'd need more exploits to access it.

cookie.php has the juicy bits though. We can see the `permissions` class which is serialized and saved to the browser cookie (the same one as in Cereal Hacker 1). But then we can see this helpful piece of laziness:

```
/* legacy login */
class siteuser
{
	public $username;
	public $password;
	
	function __construct($u, $p){
		$this->username = $u;
		$this->password = $p;
	}

	function is_admin(){
		global $sql_conn;
		if($sql_conn->connect_errno){
			die('Could not connect');
		}
		$q = 'SELECT admin FROM pico_ch2.users WHERE admin = 1 AND username = \''.$this->username.'\' AND (password = \''.$this->password.'\');';
		
		$result = $sql_conn->query($q);
		if($result->num_rows != 1){
			$is_user_val = 0;
		}
		else{
			$is_user_val = 1;
		}
		
		$sql_conn->close();
		return $is_user_val;
	}
}
```

A legacy login class was left active in the source code, and it is vulnerable to SQL injection! So we can just use the same solution as Cereal Hacker 1 now, just changing the cookie to use the old object, right?

![](https://puu.sh/ErVC7/3721bd670d.png)

Not quite. Turns out we need to leak the admin's password for the flag.

## SQL info leak

With the ability to inject our own SQL in hand, we just need to leak the admin's password.

SQL has a helpful function called LOCATE which can tell us if/where it finds a character in a given string. To test this, we can use the following cookie:

`O:8:"siteuser":2:{s:8:"username";s:5:"admin";s:8:"password";s:51:"' OR LOCATE(binary 'p', password, 0) = 0 OR 'a' = '";}`

The above injection checks if the letter 'p' is at position 0 of the user's password. When we use this as our cookie, *the login page says we are admin*. If we change it to check any other letter, the login page says we aren't admin. We now know that the first letter of the password is 'p'! We can check again by changing the index to 1 and testing the letter 'i'. Once again, it thinks we are admin. This confirms our info leak is working as the start of the password is likely `picoCTF`.

Note: The `binary` keyword in the injection ensures our check is case-sensitive.

Our solution simply brute-forces the flag by making requests with every likely ASCII character for each position of the password until the login page thinks we are admin. The script ends when it can't find a new character.